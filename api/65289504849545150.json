{"meta":{"title":"ES6笔记(中）","date":"2016-04-02T15:17:19.000Z","tags":["ES6"],"categories":"笔记","thumbnail":"http://7xt64w.com2.z0.glb.clouddn.com/owl-158414_1280.png","id":"65289504849545150","length":10932,"next":{"title":"Permission denied解决办法","id":"2786150484954514953"},"prev":{"title":"ES6笔记(上）","id":"6528950484954504954"}},"content":"<h2>二进制数组</h2>\n<h3>概念</h3>\n<p>二进制数组内容<code>ArrayBuffer</code>，通过<code>TypeArray</code>和<code>DataView</code>两个对象接口来读写。</p>\n <!-- more -->\n<table>\n<thead>\n<tr>\n<th>数组类型</th>\n<th>含义</th>\n<th>字节长度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Int8</code></td>\n<td>8位带符号整数</td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>Int16</code></td>\n<td>8位带符号整数</td>\n<td>2</td>\n</tr>\n<tr>\n<td><code>Int32</code></td>\n<td>8位带符号整数</td>\n<td>4</td>\n</tr>\n<tr>\n<td><code>Uint8</code></td>\n<td>8位带符号整数</td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>Uint8C</code></td>\n<td>8位带符号整数</td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>Uint16</code></td>\n<td>8位带符号整数</td>\n<td>2</td>\n</tr>\n<tr>\n<td><code>UInt32</code></td>\n<td>8位带符号整数</td>\n<td>4</td>\n</tr>\n<tr>\n<td><code>Float32</code></td>\n<td>8位带符号整数</td>\n<td>4</td>\n</tr>\n<tr>\n<td><code>Float64</code></td>\n<td>8位带符号整数</td>\n<td>8</td>\n</tr>\n</tbody>\n</table>\n<p><em>注意，二进制数组并不是真正的数组，而是类似数组的对象。</em></p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-keyword\">var</span> buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ArrayBuffer</span>(<span class=\"hljs-number\">32</span>); <span class=\"hljs-comment\">//实例化对象</span>\n<span class=\"hljs-keyword\">var</span> dataView = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">DataView</span>(buf); <span class=\"hljs-comment\">//传入二进制对象(必须)</span>\ndataView.getUint8(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 0</span>\n\n<span class=\"hljs-comment\">//9种TypeArray都可以由构造函数创建</span>\n<span class=\"hljs-keyword\">var</span> x1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int32Array</span>(buf); \n<span class=\"hljs-comment\">//or 默认是0,成员连续且不为空</span>\n<span class=\"hljs-keyword\">var</span> x2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int32Array</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [0,0,0]</span>\n<span class=\"hljs-comment\">//or</span>\n<span class=\"hljs-keyword\">var</span> x3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int32Array</span>([<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>]);\n<span class=\"hljs-comment\">//可以接受任何类型的数组</span>\n<span class=\"hljs-keyword\">var</span> x3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int32Array</span>(<span class=\"hljs-keyword\">new</span> Int8(<span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">//[0,0,0]</span>\n<span class=\"hljs-comment\">//同普通数组操作一致</span>\nx3[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// [0,0,1]</span>\n\nbuf.byteLength == <span class=\"hljs-number\">32</span> <span class=\"hljs-comment\">//true</span>\n<span class=\"hljs-built_in\">Int8Array</span>.BYTES_PER_ELEMEN <span class=\"hljs-comment\">//2</span>\nx3.byteLength <span class=\"hljs-comment\">//3</span>\nx3.byteOffset <span class=\"hljs-comment\">//0</span>\n\n<span class=\"hljs-comment\">//\tslice是ArrayBuffer唯一允许的可以直接读写的方法，分配同等大小的内存空间，再将内容拷贝过去。</span>\n<span class=\"hljs-keyword\">var</span> newBuffer = buf.slice(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-comment\">//isView判断参数是否是视图实例，ArrayBuffer是全局变量</span>\n<span class=\"hljs-built_in\">ArrayBuffer</span>.isView(buf);<span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-built_in\">ArrayBuffer</span>.isView(dataView);<span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-built_in\">ArrayBuffer</span>.isView(x2);<span class=\"hljs-comment\">// true</span>\n\n<span class=\"hljs-comment\">//自定义视图 new TypedArray(buffer, byteOffset=0, length)</span>\n<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ArrayBuffer</span>(<span class=\"hljs-number\">8</span>);\n<span class=\"hljs-comment\">//创建32位整型，长度与buffer一样为8字节</span>\n<span class=\"hljs-keyword\">var</span> v1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int32Array</span>(b);\n<span class=\"hljs-comment\">//byteOffset起始边界为字节2，直至末尾</span>\n<span class=\"hljs-keyword\">var</span> v2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Uint8Array</span>(b, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-comment\">//length长度为2，即从2字节边界起，扩展2字节长度16位整型</span>\n<span class=\"hljs-keyword\">var</span> v3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int16Array</span>(b, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>);\t\n\n<span class=\"hljs-comment\">//byteOffset要与TypeArray保持一致，8位整型最小单位是2字节</span>\n<span class=\"hljs-keyword\">var</span> v2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Uint8Array</span>(b, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-comment\">// Uncaught RangeError: start offset of Int16Array should be a multiple of 2</span>\n\n<span class=\"hljs-comment\">//返回普通数组</span>\n<span class=\"hljs-keyword\">var</span> normalArray = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(typedArray);\n\n<span class=\"hljs-comment\">//可以遍历</span>\n<span class=\"hljs-keyword\">let</span> ui8 = <span class=\"hljs-built_in\">Uint8Array</span>.of(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> byte <span class=\"hljs-keyword\">of</span> ui8) {\n  <span class=\"hljs-built_in\">console</span>.log(byte);\n}\n\n<span class=\"hljs-comment\">//溢出</span>\n<span class=\"hljs-comment\">//当赋值大于数据类型最大值,正向溢出,数据类型的最小值加上余值,再减去1</span>\n<span class=\"hljs-comment\">//当赋值小于数据类型最小值,负向溢出,数据类型的最大值减去余值,再加上1</span>\n<span class=\"hljs-comment\">//简便方法：减去二进制长度Uint8即减去256 </span>\n<span class=\"hljs-keyword\">var</span> uint8 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Uint8Array</span>(<span class=\"hljs-number\">1</span>);\n\nuint8[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">256</span>;\nuint8[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// 0  256-256</span>\n<span class=\"hljs-comment\">//or</span>\nUnt8[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">128</span>;\nUnt8[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// -128  126-256</span>\n<span class=\"hljs-comment\">//or</span>\nuint8[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">-1</span>;\nuint8[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// 255 255-256 </span>\n\n<span class=\"hljs-comment\">//Uint8ClampedArray是特例，通常同来表示像素属性</span>\n<span class=\"hljs-comment\">//溢出的结果都是边界</span>\n<span class=\"hljs-keyword\">var</span> uint8c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Uint8ClampedArray</span>(<span class=\"hljs-number\">1</span>);\n\nuint8c[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">256</span>;\nuint8c[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// 255</span>\n\nuint8c[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">-1</span>;\nuint8c[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// 0</span>\n\n<span class=\"hljs-comment\">//复制数组，比拷贝数组效率更高</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Uint8Array</span>(<span class=\"hljs-number\">8</span>);\n<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Uint8Array</span>(<span class=\"hljs-number\">8</span>);\n\nb.set(a);\nb.set(a,<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\">//数组截断,返回一个新数组,@参数 开始序号，结束序号</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Uint16Array</span>(<span class=\"hljs-number\">8</span>);\n<span class=\"hljs-keyword\">var</span> b = a.subarray(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>);\na.byteLength <span class=\"hljs-comment\">// 16</span>\nb.byteLength <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-comment\">//数组切割</span>\n<span class=\"hljs-keyword\">let</span> ui8 = <span class=\"hljs-built_in\">Uint8Array</span>.of(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\nui8.slice(<span class=\"hljs-number\">-1</span>) <span class=\"hljs-comment\">//[2]</span>\n<span class=\"hljs-comment\">//from @参数，数组元素，遍历函数</span>\n<span class=\"hljs-built_in\">Int16Array</span>.from(<span class=\"hljs-built_in\">Int8Array</span>.of(<span class=\"hljs-number\">127</span>, <span class=\"hljs-number\">126</span>, <span class=\"hljs-number\">125</span>), x =&gt; <span class=\"hljs-number\">2</span> * x)\n\n</code></pre>\n<h3>应用</h3>\n<h4>AJAX,WebSocket,Fetch</h4>\n<p>传统上，服务器通过AJAX操作只能返回文本数据，即responseType属性默认为text。XMLHttpRequest第二版XHR2允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responseType）设为arraybuffer；如果不知道，就设为blob。</p>\n<p>Websocket可以允许发送，并接收<code>arrayBuffer</code>。</p>\n<p>Fetch API取回的数据，就是<code>ArrayBuffer</code>对象</p>\n<h4>Canvas</h4>\n<p>Canvas的<code>getImageData</code>返回对象中的<code>data</code>就是<code>Uint8ClampedArray</code>，这个类型数组也是专门为这个api设计的。即当颜色超出255时，或者小于0时 不会溢出，取边界值。</p>\n<h2>Set和Map数据结构</h2>\n<h3>Set</h3>\n<p>Set是一种新的数据结构,特点是内容不重复。</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-keyword\">var</span> _set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">//Set {1,2,3}</span>\n\n<span class=\"hljs-comment\">// Set内部判断与一般不同，NaN等于自身，即只能插入一次</span>\n_set.add(<span class=\"hljs-literal\">NaN</span>);\n_set.add(<span class=\"hljs-literal\">NaN</span>);<span class=\"hljs-comment\">//Set {1,2,3,NaN}</span>\n\n<span class=\"hljs-comment\">// Set有两个属性 size,constructor</span>\n<span class=\"hljs-built_in\">console</span>.log(_set.size); <span class=\"hljs-comment\">//4</span>\n<span class=\"hljs-built_in\">console</span>.log(_set.constructor); <span class=\"hljs-comment\">// function Set()</span>\n\n<span class=\"hljs-comment\">// Set有4个方法add,delete,has,value</span>\n_set.add(<span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// {1,2,3,NaN,4}</span>\n_set.delete(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">//{2,3,NaN,4}</span>\n_set.has(<span class=\"hljs-literal\">NaN</span>) <span class=\"hljs-comment\">//true</span>\n_set.clear() <span class=\"hljs-comment\">//Set {}</span>\n\n<span class=\"hljs-comment\">// 可以与数组间相互转化</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>])) <span class=\"hljs-comment\">//[1,2,3]</span>\n\n<span class=\"hljs-comment\">// 数组去重</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dedupe</span>(<span class=\"hljs-params\">array</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>(array));\n  <span class=\"hljs-comment\">// return [...new Set(array)] 更简单的</span>\n}\ndedupe([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]) <span class=\"hljs-comment\">// [1, 2, 3]</span>\n\n<span class=\"hljs-comment\">// Set同其他数据结构一样，可以通过key,value,entries,forEach遍历,</span>\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> _set.entries() ){\n  <span class=\"hljs-built_in\">console</span>.log(item);\n}\n<span class=\"hljs-comment\">// [1,1]</span>\n<span class=\"hljs-comment\">// [2,2]</span>\n<span class=\"hljs-comment\">// [3,3]</span>\n<span class=\"hljs-comment\">// 但是键名和键值是同一个值</span>\n\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>]);\n<span class=\"hljs-comment\">//实现并集，交集，差集,前提是没有重复的值</span>\n<span class=\"hljs-comment\">//利用has取相同的值</span>\n<span class=\"hljs-keyword\">let</span> union = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([...a, ...b]); <span class=\"hljs-comment\">// [1,2,3,4]</span>\n<span class=\"hljs-keyword\">let</span> intersect = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([...a].filter(x =&gt; b.has(x))); <span class=\"hljs-comment\">// [2, 3]</span>\n<span class=\"hljs-keyword\">let</span> difference = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([...a].filter(x =&gt; !b.has(x))); <span class=\"hljs-comment\">// [1]</span>\n\n</code></pre>\n<h3>WeakSet</h3>\n<p>故名思议，弱化的Set。</p>\n<ul>\n<li>相同点：没有重复内容</li>\n<li>不同点：内容只能是对象；不可遍历</li>\n</ul>\n<p>WeakSet包含</p>\n<p>一个属性 <code>constructor</code>\n三个方法 <code>add()</code>,<code>delete()</code>.<code>has()</code></p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-comment\">//通过构造函数创建</span>\n<span class=\"hljs-keyword\">var</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakSet</span>();\n\n<span class=\"hljs-keyword\">var</span> b = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n<span class=\"hljs-keyword\">var</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakSet</span>(b);\n<span class=\"hljs-comment\">// Uncaught TypeError: Invalid value used in weak set(…)</span>\n<span class=\"hljs-comment\">// 试图向ws添加内容3,4</span>\n\n<span class=\"hljs-keyword\">var</span> a = [[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>]];\n<span class=\"hljs-keyword\">var</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakSet</span>(a); <span class=\"hljs-comment\">// WeakSet {[1, 2], [3, 4]}</span>\n<span class=\"hljs-comment\">//向ws添加的是两队数组对象,而不是数组本身</span>\n</code></pre>\n<h3>Map</h3>\n<h4>概念</h4>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-keyword\">var</span> data = {};\n<span class=\"hljs-keyword\">var</span> element = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">\"myDiv\"</span>);\n\ndata[element] = metadata;\ndata[<span class=\"hljs-string\">\"[Object HTMLDivElement]\"</span>] <span class=\"hljs-comment\">// metadata</span>\n</code></pre>\n<p>Map的产生就是就来解决上面这种情况的，对象中的键名只接受字符串</p>\n<p>Map同Set一样含有两个属性，5个方法，可遍历，遍历方法同数组和对象一致</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([[<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"张三\"</span>], [<span class=\"hljs-string\">\"title\"</span>, <span class=\"hljs-string\">\"Author\"</span>]]);\n<span class=\"hljs-comment\">// Map {\"name\" =&gt; \"张三\", \"title\" =&gt; \"Author\"} </span>\n<span class=\"hljs-comment\">// 传入的数组中可遍历的内容，不是本身</span>\n\n<span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();\n<span class=\"hljs-comment\">// 可接受任何类型的键值,除了Null</span>\nm.set(<span class=\"hljs-string\">\"edition\"</span>, <span class=\"hljs-number\">6</span>)        <span class=\"hljs-comment\">// 键是字符串</span>\nm.set(<span class=\"hljs-number\">262</span>, <span class=\"hljs-string\">\"standard\"</span>)     <span class=\"hljs-comment\">// 键是数值</span>\nm.set(<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"nah\"</span>)    <span class=\"hljs-comment\">// 键是undefined</span>\nm.set(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">\"nah\"</span>)    <span class=\"hljs-comment\">// 键是null</span>\nm.set(Null, <span class=\"hljs-string\">\"nah\"</span>)    <span class=\"hljs-comment\">// 键是undefined</span>\n<span class=\"hljs-comment\">// Uncaught ReferenceError: Null is not defined</span>\n\n<span class=\"hljs-comment\">// has用来查找键名而不是键值</span>\nmap.has(<span class=\"hljs-string\">\"name\"</span>) <span class=\"hljs-comment\">// true</span>\nmap.has(<span class=\"hljs-string\">\"Author\"</span>) <span class=\"hljs-comment\">//false</span>\n\n<span class=\"hljs-comment\">// 删除键值对，@参数是可以key</span>\n<span class=\"hljs-comment\">// map.delete(\"name\") // true</span>\n\n<span class=\"hljs-comment\">// 清除所有成员</span>\nmap.clear();\n</code></pre>\n<h4>数据结构间相互转化</h4>\n<p>Map与其他三种Array，Object，JSON六种相互转换</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-comment\">// Map =&gt; Array</span>\n<span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>().set(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">7</span>).set({foo: <span class=\"hljs-number\">3</span>}, [<span class=\"hljs-string\">'abc'</span>]);\n[...myMap]\n<span class=\"hljs-comment\">// Array =&gt; Map</span>\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([[<span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">7</span>], [{foo: <span class=\"hljs-number\">3</span>}, [<span class=\"hljs-string\">'abc'</span>]]])\n<span class=\"hljs-comment\">// Map =&gt; {}</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">strMapToObj</span>(<span class=\"hljs-params\">strMap</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-built_in\">Object</span>.create(<span class=\"hljs-literal\">null</span>);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [k,v] <span class=\"hljs-keyword\">of</span> strMap) {\n    obj[k] = v;\n  }\n  <span class=\"hljs-keyword\">return</span> obj;\n}\n\n<span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>().set(<span class=\"hljs-string\">'yes'</span>, <span class=\"hljs-literal\">true</span>).set(<span class=\"hljs-string\">'no'</span>, <span class=\"hljs-literal\">false</span>);\nstrMapToObj(myMap)\n<span class=\"hljs-comment\">// { yes: true, no: false }</span>\n\n<span class=\"hljs-comment\">// {} =&gt; Map</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">objToStrMap</span>(<span class=\"hljs-params\">obj</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> strMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> k <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">Object</span>.keys(obj)) {\n    strMap.set(k, obj[k]);\n  }\n  <span class=\"hljs-keyword\">return</span> strMap;\n}\nobjToStrMap({yes: <span class=\"hljs-literal\">true</span>, no: <span class=\"hljs-literal\">false</span>})\n<span class=\"hljs-comment\">// [ [ 'yes', true ], [ 'no', false ] ]</span>\n\n<span class=\"hljs-comment\">// Map =&gt; JSON</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">strMapToJson</span>(<span class=\"hljs-params\">strMap</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">JSON</span>.stringify(strMapToObj(strMap));\n}\n\n<span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>().set(<span class=\"hljs-string\">'yes'</span>, <span class=\"hljs-literal\">true</span>).set(<span class=\"hljs-string\">'no'</span>, <span class=\"hljs-literal\">false</span>);\nstrMapToJson(myMap)\n<span class=\"hljs-comment\">// '{\"yes\":true,\"no\":false}'</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mapToArrayJson</span>(<span class=\"hljs-params\">map</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">JSON</span>.stringify([...map]);\n}\n<span class=\"hljs-comment\">// 当键名中有非字符串</span>\n<span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>().set(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">7</span>).set({foo: <span class=\"hljs-number\">3</span>}, [<span class=\"hljs-string\">'abc'</span>]);\nmapToArrayJson(myMap)\n<span class=\"hljs-comment\">// '[[true,7],[{\"foo\":3},[\"abc\"]]]'</span>\n\n<span class=\"hljs-comment\">//JSON转Map</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">jsonToStrMap</span>(<span class=\"hljs-params\">jsonStr</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> objToStrMap(<span class=\"hljs-built_in\">JSON</span>.parse(jsonStr));\n}\njsonToStrMap(<span class=\"hljs-string\">'{\"yes\":true,\"no\":false}'</span>)\n<span class=\"hljs-comment\">// Map {'yes' =&gt; true, 'no' =&gt; false}</span>\n</code></pre>\n<h3>WeakMap</h3>\n<p>WeakMap只接受只接受对象作为键名，当对象被回收，同时移除对应的键值对。不可遍历，可以使用Map的4个方法。</p>\n<p>它有两个作用，一是在js中为DOM元素设置属性</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-keyword\">let</span> myElement = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'logo'</span>);\n<span class=\"hljs-keyword\">let</span> myWeakmap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>();\n\nmyWeakmap.set(myElement, {timesClicked: <span class=\"hljs-number\">0</span>});\n\nmyElement.addEventListener(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> logoData = myWeakmap.get(myElement);\n  logoData.timesClicked++;\n  myWeakmap.set(myElement, logoData);\n}, <span class=\"hljs-literal\">false</span>);\n</code></pre>\n<p>第二个是设置对象的私有属性，当对象被回收，属性也会消失,不占用内存</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-keyword\">let</span> _counter = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>();\n<span class=\"hljs-keyword\">let</span> _action = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>();\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Countdown</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(counter, action) {\n    _counter.set(<span class=\"hljs-keyword\">this</span>, counter);\n    _action.set(<span class=\"hljs-keyword\">this</span>, action);\n  }\n  dec() {\n    <span class=\"hljs-keyword\">let</span> counter = _counter.get(<span class=\"hljs-keyword\">this</span>);\n    <span class=\"hljs-keyword\">if</span> (counter &lt; <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;\n    counter--;\n    _counter.set(<span class=\"hljs-keyword\">this</span>, counter);\n    <span class=\"hljs-keyword\">if</span> (counter === <span class=\"hljs-number\">0</span>) {\n      _action.get(<span class=\"hljs-keyword\">this</span>)();\n    }\n  }\n}\n\n<span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-keyword\">new</span> Countdown(<span class=\"hljs-number\">2</span>, () =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'DONE'</span>));\n\nc.dec()\nc.dec()\n</code></pre>\n<h2>遍历器</h2>\n<p>###概念\n遍历器是用来给满足数据结构对象提供一种统计的遍历机制，也在创建数据结构是检测是否满足遍历要求，它部署在<code>Symbol.iterator</code>属性上面。</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>])\n<span class=\"hljs-built_in\">console</span>.log(a)\n<span class=\"hljs-comment\">// Uncaught TypeError: Iterator value 1 is not an entry object(…)</span>\n</code></pre>\n<p>对象没有部署<code>iterator</code>，是因为其没有标明顺序的序号即入口。但是你可以手动在其原型链上部署遍历器：<code>Object.prototype[Symbol.iterator]</code>。</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>],[<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]])\n<span class=\"hljs-built_in\">console</span>.dir(a)\n<span class=\"hljs-comment\">// Map</span>\n<span class=\"hljs-comment\">//   size: 2</span>\n<span class=\"hljs-comment\">//   __proto__: Map</span>\n<span class=\"hljs-comment\">//   &lt;entries&gt;[2]</span>\n<span class=\"hljs-comment\">//     0: {1 =&gt; 2}</span>\n<span class=\"hljs-comment\">//     1: {2 =&gt; 3}</span>\n\n<span class=\"hljs-comment\">// 遍历器函数</span>\n<span class=\"hljs-built_in\">Object</span>.prototype[<span class=\"hljs-built_in\">Symbol</span>.iterator] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n\n  <span class=\"hljs-keyword\">var</span> iterator = {\n    next: next\n  };\n\n  <span class=\"hljs-keyword\">var</span> current = <span class=\"hljs-keyword\">this</span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">next</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-keyword\">if</span> (current){\n      <span class=\"hljs-keyword\">var</span> value = current.value;\n      <span class=\"hljs-keyword\">var</span> done = current == <span class=\"hljs-literal\">null</span>;\n      current = current.next;\n      <span class=\"hljs-keyword\">return</span> {\n        done: done,\n        value: value\n      }\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> {\n        done: <span class=\"hljs-literal\">true</span>\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> iterator;\n}\n\n<span class=\"hljs-comment\">//也可以直接引用</span>\n<span class=\"hljs-built_in\">Object</span>.prototype[<span class=\"hljs-built_in\">Symbol</span>.iterator] = <span class=\"hljs-built_in\">Array</span>.prototype[<span class=\"hljs-built_in\">Symbol</span>.iterator]\n\n<span class=\"hljs-comment\">// 数组的遍历器接口只返回具有数字索引的属性，for...in只返回键名</span>\n<span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>];\narr.foo = <span class=\"hljs-string\">'hello'</span>;\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">in</span> arr) {\n  <span class=\"hljs-built_in\">console</span>.log(i); <span class=\"hljs-comment\">// \"0\", \"1\", \"2\", \"foo\"</span>\n}\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> arr) {\n  <span class=\"hljs-built_in\">console</span>.log(i); <span class=\"hljs-comment\">//  \"3\", \"5\", \"7\"</span>\n}\n</code></pre>\n<p>自定义遍历器必须包含<code>next()</code>方法，但是<code>return()</code>和<code>throw()</code>这两个方法是可选的。</p>\n<h3>使用场景</h3>\n<ol>\n<li>解构赋值</li>\n<li>扩展运算符（<code>...</code>）</li>\n<li><code>yield*</code>后面跟的是一个可遍历的结构</li>\n<li><code>for...of</code></li>\n<li><code>Array.from()</code></li>\n<li><code>Map()</code>, <code>Set()</code>, <code>WeakMap()</code>, <code>WeakSet()</code></li>\n<li><code>Promise.all()</code></li>\n<li><code>Promise.race()</code></li>\n</ol>\n<h2>Generator 函数</h2>\n<h3>概念</h3>\n<p>迭代器本身是有一个带*的<code>function</code>关键词，以及函数内部的<code>yield</code>语句组成的。<code>yield</code>只能在<code>Generator</code>函数内部，其它情况下会报错。\n函数使用和普通函数一样，在其后跟一对<code>()</code>,但是此时函数不会执行，只返回一个引用指针，这也是<code>Generator</code>函数无法创建构造函数的原因。这时传入的参数，也将会在其第一次调用<code>next()</code>方法是传入。所以迭代器的第一个<code>next()</code>是没有参数的。执行时会循环调用<code>iterator</code>的<code>next()</code>来修改函数的状态。<code>yield</code>后面表达式会被执行，如果是值则返回。停止等待下一次调用。</p>\n<p>Generator函数也包含一个遍历器等于自身</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">gen</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-comment\">// some code</span>\n}\n<span class=\"hljs-keyword\">var</span> g = gen();\ng[<span class=\"hljs-built_in\">Symbol</span>.iterator]() === g\n<span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>Generator包含两个方法<code>throw</code>以及<code>return</code>，前者用来捕获内部的错误，不中断执行，后者用来返回对应的值，同时中断执行。</p>\n<p>如果要在迭代器内部嵌套，则需要用到<code>*</code>关键词，不能直接嵌套</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'x'</span>;\n  <span class=\"hljs-keyword\">yield</span>* foo();\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'y'</span>;\n}\n\n<span class=\"hljs-comment\">// 等同于</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'x'</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'a'</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'b'</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'y'</span>;\n}\n</code></pre>\n<h3>应用</h3>\n<h4>二叉树遍历</h4>\n<p>基于迭代嵌套，实现二叉树遍历</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-comment\">// 下面是二叉树的构造函数，</span>\n<span class=\"hljs-comment\">// 三个参数分别是左树、当前节点和右树</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Tree</span>(<span class=\"hljs-params\">left, label, right</span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.left = left;\n  <span class=\"hljs-keyword\">this</span>.label = label;\n  <span class=\"hljs-keyword\">this</span>.right = right;\n}\n\n<span class=\"hljs-comment\">// 下面是中序（inorder）遍历函数。</span>\n<span class=\"hljs-comment\">// 由于返回的是一个遍历器，所以要用generator函数。</span>\n<span class=\"hljs-comment\">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">inorder</span>(<span class=\"hljs-params\">t</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (t) {\n    <span class=\"hljs-keyword\">yield</span>* inorder(t.left);\n    <span class=\"hljs-keyword\">yield</span> t.label;\n    <span class=\"hljs-keyword\">yield</span>* inorder(t.right);\n  }\n}\n\n<span class=\"hljs-comment\">// 下面生成二叉树</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">make</span>(<span class=\"hljs-params\">array</span>) </span>{\n  <span class=\"hljs-comment\">// 判断是否为叶节点</span>\n  <span class=\"hljs-keyword\">if</span> (array.length == <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Tree(<span class=\"hljs-literal\">null</span>, array[<span class=\"hljs-number\">0</span>], <span class=\"hljs-literal\">null</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Tree(make(array[<span class=\"hljs-number\">0</span>]), array[<span class=\"hljs-number\">1</span>], make(array[<span class=\"hljs-number\">2</span>]));\n}\n<span class=\"hljs-keyword\">let</span> tree = make([[[<span class=\"hljs-string\">'a'</span>], <span class=\"hljs-string\">'b'</span>, [<span class=\"hljs-string\">'c'</span>]], <span class=\"hljs-string\">'d'</span>, [[<span class=\"hljs-string\">'e'</span>], <span class=\"hljs-string\">'f'</span>, [<span class=\"hljs-string\">'g'</span>]]]);\n\n<span class=\"hljs-comment\">// 遍历二叉树</span>\n<span class=\"hljs-keyword\">var</span> result = [];\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> node <span class=\"hljs-keyword\">of</span> inorder(tree)) {\n  result.push(node);\n}\n\nresult\n<span class=\"hljs-comment\">// ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span>\n</code></pre>\n<h4>控制流管理</h4>\n<p>原始回调</p>\n<pre class=\"hljs\" lang=js><code>step1(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value1</span>) </span>{\n  step2(value1, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value2</span>) </span>{\n    step3(value2, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value3</span>) </span>{\n      step4(value3, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value4</span>) </span>{\n        <span class=\"hljs-comment\">// Do something with value4</span>\n      });\n    });\n  });\n});\n</code></pre>\n<p>利用<code>Promise</code></p>\n<pre class=\"hljs\" lang=js><code>Q.fcall(step1)\n  .then(step2)\n  .then(step3)\n  .then(step4)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value4</span>) </span>{\n    <span class=\"hljs-comment\">// Do something with value4</span>\n  }, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error</span>) </span>{\n    <span class=\"hljs-comment\">// Handle any error from step1 through step4</span>\n  })\n  .done();\n</code></pre>\n<p>用Generator函数改写</p>\n<pre class=\"hljs\" lang=js><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">longRunningTask</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">var</span> value1 = <span class=\"hljs-keyword\">yield</span> step1();\n    <span class=\"hljs-keyword\">var</span> value2 = <span class=\"hljs-keyword\">yield</span> step2(value1);\n    <span class=\"hljs-keyword\">var</span> value3 = <span class=\"hljs-keyword\">yield</span> step3(value2);\n    <span class=\"hljs-keyword\">var</span> value4 = <span class=\"hljs-keyword\">yield</span> step4(value3);\n    <span class=\"hljs-comment\">// Do something with value4</span>\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-comment\">// Handle any error from step1 through step4</span>\n  }\n}\n\nscheduler(longRunningTask()); <span class=\"hljs-comment\">//自动调用</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">scheduler</span>(<span class=\"hljs-params\">task</span>) </span>{\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> taskObj = task.next(task.value);\n    <span class=\"hljs-comment\">// 如果Generator函数未结束，就继续调用</span>\n    <span class=\"hljs-keyword\">if</span> (!taskObj.done) {\n      task.value = taskObj.value\n      scheduler(task);\n    }\n  }, <span class=\"hljs-number\">0</span>);\n}\n</code></pre>\n"}