{"meta":{"title":"ES6笔记(上）","date":"2016-03-15T20:20:19.000Z","tags":["ES6"],"categories":"笔记","thumbnail":"http://7xt64w.com2.z0.glb.clouddn.com/owl-158414_1280.png","id":"6528950484954504954","snapshot":"<h2>没关系的引导语</h2>\n<blockquote>\n<p>Zach LaVine: &quot;You're always going to remember. It's never going to fade. Time is a little bit like scars. There's still a little bit of the scar.&quot;</p>\n</blockquote>\n <!--more-->\n<h2>笔记</h2>\n<h3>let块级声明</h3>\n<ol>\n<li>与<code>var</code>不同，不存在变量提升。</li>\n<li>高于全</li></ol></!--more-->"},"content":"<h2>没关系的引导语</h2>\n<blockquote>\n<p>Zach LaVine: &quot;You're always going to remember. It's never going to fade. Time is a little bit like scars. There's still a little bit of the scar.&quot;</p>\n</blockquote>\n <!--more-->\n<h2>笔记</h2>\n<h3>let块级声明</h3>\n<ol>\n<li>与<code>var</code>不同，不存在变量提升。</li>\n<li>高于全局变量，即在块作用域内，如果let声明了变量，要使用，必须在区块内的定义后。</li>\n<li>存在暂时性死区（Temporial Dead Zone），声明之前，直接使用变量会报错，不会返回<code>undefined</code></li>\n<li>在TDZ内，使用<code>typeof</code>也会报错</li>\n</ol>\n<h3>为什么要用块级作用域</h3>\n<ol>\n<li>避免覆盖全局变量（局部内重新定义全局变量）</li>\n<li>避免局部泄露至全局（局部内操作全局函数，退出后会泄露值）</li>\n<li>代替立即执行匿名函数（我们为了避免污染而创造的）</li>\n</ol>\n<blockquote>\n<p>ES5的严格模式下，循环内不能定义函数。</p>\n</blockquote>\n<h3>定义</h3>\n<ol>\n<li>const常量定义一定要赋值，不能先定义，再赋值。</li>\n<li>解耦定义<code>[a,b,c] = [1,2,3]</code></li>\n<li>交换变量<code>[x,y]=[y,x]</code></li>\n</ol>\n<h3>迭代</h3>\n<ol>\n<li><code>for( a of obj )</code>遍历属性</li>\n<li><code>for( [key] of obj )</code>遍历键值</li>\n<li><code>for( [,value] of obj)</code>遍历值</li>\n<li><code>for( [key,value] of obj)</code>完整的遍历</li>\n</ol>\n<h3>字符串扩展</h3>\n<ol>\n<li><code>includes(str,idx)</code>判断查找从idx起是否包含str字符串</li>\n<li><code>startsWith(str,idx)</code>判断从idx起是否已str开头</li>\n<li><code>endsWith(str,idx)</code>判断从idx起是否已str结尾</li>\n<li><code>repeat(count)</code>返回重复count次数的当前字符串，自动取整</li>\n<li><code>padStart(len,str)</code>在字符串前补全长度为len的str</li>\n<li><code>padEnd()</code>在字符串后补全长度为len的str</li>\n<li><code>raw()</code>返回替换变量后的模板字符串</li>\n</ol>\n<h3>Number扩展</h3>\n<ol>\n<li><code>isNaN()</code>判断是否是Nan，ES5中<code>NaN</code>不能其本身</li>\n<li><code>isFinite()</code>判断是否有穷</li>\n<li><code>parseInt()</code>原来全局函数，移植到Number上</li>\n<li><code>isInteger()</code>判断是否是整数</li>\n<li><code>epsilon()</code>返回一个极小数，为了判断浮点数计算</li>\n<li><code>isSafeInteger()</code>用来判断传入的参数值是否是一个“安全整数”（处于 -(2^53 -1) 和 2^53 -1 之间的整数）。</li>\n</ol>\n<h3>数学方法扩展</h3>\n<ol>\n<li><code>Math.sinh(x)</code> 返回x的双曲正弦</li>\n<li><code>Math.cosh(x)</code> 返回x的双曲余弦</li>\n<li><code>Math.tanh(x)</code> 返回x的双曲正切</li>\n<li><code>Math.asinh(x)</code> 返回x的反双曲正弦</li>\n<li><code>Math.acosh(x)</code> 返回x的反双曲余弦</li>\n<li><code>Math.atanh(x)</code> 返回x的反双曲正切</li>\n<li><code>trunc()</code> 去除小数</li>\n<li><code>sign()</code>判断正负</li>\n<li><code>cbrt()</code>返回立方根</li>\n<li><code>clz32()</code>回一个数的32位无符号整数形式有多少个前导0</li>\n<li><code>Math.imul()</code>JavaScript有精度限制，超过2的53次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。</li>\n<li><code>hypot()</code>平和方的开放，类似勾股定理</li>\n<li><code>expm1(x)=&gt;e^x-1</code>自然数指数</li>\n<li><code>log1p()=&gt;log(1+x)</code>自然对数</li>\n<li><code>log10()</code>以10为底的对数</li>\n<li><code>log2()</code>以2为底的对数</li>\n</ol>\n<h3>数组扩展</h3>\n<ol>\n<li>\n<p><code>Array.from(obj,statement)</code>将可枚举对象转为数组，做值修改\n常见的Dom节点组</p>\n<pre class=\"hljs\"><code>querySelectAll -&gt; nodelist \n\n<span class=\"hljs-keyword\">from</span>(nodelist).foreach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">p</span>)</span>{})\n</code></pre>\n</li>\n<li>\n<p><code>Array.of()=&gt; []</code> 将一组值转为数组</p>\n</li>\n<li>\n<p><code>copyWith(target,start,end)</code>从target位置开始替换数组，替换为从start位置开始取的值，end默认为数组长度</p>\n<pre class=\"hljs\"><code>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].copyWithin(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>)\n<span class=\"hljs-comment\">// [4, 5, 3, 4, 5]</span>\n</code></pre>\n</li>\n<li>\n<p><code>Array.of()=&gt; []</code> 将一组值转为数组</p>\n</li>\n<li>\n<p><code>find(callback(value, index, arr))</code>找出第一个符合条件的数组成员</p>\n<pre class=\"hljs\"><code>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">10</span>].find((n) =&gt; n &lt; <span class=\"hljs-number\">0</span>)\n</code></pre>\n</li>\n<li>\n<p><code>findIndex(callback(value, index, arr))</code>找出第一个符合条件的数组成员的索引</p>\n</li>\n<li>\n<p><code>entries()</code>返回键值对</p>\n</li>\n<li>\n<p><code>keys()</code>返回键值</p>\n</li>\n<li>\n<p><code>values()</code>返回值</p>\n</li>\n<li>\n<p><code>includes(,start)</code>数组是否包含特定值</p>\n</li>\n<li>\n<p><code>copyWith(target, start, end)</code>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p>\n</li>\n</ol>\n<h3>数组推导</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> years = [ <span class=\"hljs-number\">1954</span>, <span class=\"hljs-number\">1974</span>, <span class=\"hljs-number\">1990</span>, <span class=\"hljs-number\">2006</span>, <span class=\"hljs-number\">2010</span>, <span class=\"hljs-number\">2014</span> ];\n\n[<span class=\"hljs-keyword\">for</span> (year <span class=\"hljs-keyword\">of</span> years) <span class=\"hljs-keyword\">if</span> (year &gt; <span class=\"hljs-number\">2000</span>) year];\n</code></pre>\n<p>遍历json</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> customers = [\n  {\n    name: <span class=\"hljs-string\">'Jack'</span>,\n    age: <span class=\"hljs-number\">25</span>,\n    city: <span class=\"hljs-string\">'New York'</span>\n  },\n  {\n    name: <span class=\"hljs-string\">'Peter'</span>,\n    age: <span class=\"hljs-number\">30</span>,\n    city: <span class=\"hljs-string\">'Seattle'</span>\n  }\n];\n\n<span class=\"hljs-keyword\">var</span> results = [\n  <span class=\"hljs-keyword\">for</span> (c <span class=\"hljs-keyword\">of</span> customers)\n    <span class=\"hljs-keyword\">if</span> (c.city == <span class=\"hljs-string\">\"Seattle\"</span>)\n      { name: c.name, age: c.age }\n];\nresults <span class=\"hljs-comment\">// { name: \"Peter\", age: 30 }</span>\n</code></pre>\n<h3>函数</h3>\n<ol>\n<li>\n<p>参数默认值</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x,{name='unset',address='unset'}={}</span>)\n</span></code></pre>\n<p>如果不加={} 第二个参数不能省略</p>\n<p>默认参数最好写在尾巴，可以省略</p>\n</li>\n<li>\n<p>rest 参数</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">...values</span>)</span>{\n\t <span class=\"hljs-keyword\">for</span>(val <span class=\"hljs-keyword\">in</span> values){\n\t \n\t }\n}\n\nfoo(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>);\t\n\n</code></pre>\n</li>\n<li>\n<p><code>spread</code>将一个数组转为用逗号分隔的参数序列</p>\n<pre class=\"hljs\"><code>\\\\spread =&gt; ...[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]\n[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,...[<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]]\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">...[1,2,3]</span>) \n</span></code></pre>\n</li>\n</ol>\n<ol start=\"4\">\n<li>箭头函数</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> f = v =&gt; v;\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> sum = (num1, num2) =&gt; num1 + num2;\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> sum = (num1, num2) =&gt; { <span class=\"hljs-keyword\">return</span> num1 + num2; }\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> getTempItem = id =&gt; ({ id: id, name: <span class=\"hljs-string\">\"Temp\"</span> });\n</code></pre>\n<ol start=\"5\">\n<li>简化回调函数</li>\n</ol>\n<pre class=\"hljs\"><code>[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>].map(x =&gt; x * x);\n</code></pre>\n<blockquote>\n<p>箭头函数有几个使用注意点。</p>\n</blockquote>\n<ol>\n<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>\n<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>\n<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</li>\n<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// λ演算的写法</span>\nfix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))\n\n<span class=\"hljs-comment\">// ES6的写法</span>\n<span class=\"hljs-keyword\">var</span> fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))\n               (x =&gt; f(v =&gt; x(x)(v)));\n</code></pre>\n<p>函数绑定运算符是并排的两个双冒号（<code>::</code>），双冒号左边是一个对象，右边是一个函数。</p>\n<pre class=\"hljs\"><code>foo::bar;\n<span class=\"hljs-comment\">// 等同于</span>\nbar.bind(foo); <span class=\"hljs-comment\">//foo 返回对象</span>\n</code></pre>\n<h3>尾调用优化</h3>\n<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>\n<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>\n<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> m = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> n = <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-keyword\">return</span> g(m + n);\n}\nf();\n\n<span class=\"hljs-comment\">// 等同于</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> g(<span class=\"hljs-number\">3</span>);\n}\nf();\n\n<span class=\"hljs-comment\">// 等同于</span>\ng(<span class=\"hljs-number\">3</span>);\n</code></pre>\n<p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 <code>f(x)</code>的调用帧，只保留<code>g(3)</code> 的调用帧。</p>\n<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>\n<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addOne</span>(<span class=\"hljs-params\">a</span>)</span>{\n  <span class=\"hljs-keyword\">var</span> one = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">inner</span>(<span class=\"hljs-params\">b</span>)</span>{\n    <span class=\"hljs-keyword\">return</span> b + one;\n  }\n  <span class=\"hljs-keyword\">return</span> inner(a);\n}\n</code></pre>\n<p>上面的函数不会进行尾调用优化，因为内层函数inner用到了，外层函数addOne的内部变量one。</p>\n<h3>尾递归</h3>\n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">factorial</span>(<span class=\"hljs-params\">n</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">return</span> n * factorial(n - <span class=\"hljs-number\">1</span>);\n}\n\nfactorial(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 120</span>\n</code></pre>\n<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>\n<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">factorial</span>(<span class=\"hljs-params\">n, total</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> total;\n  <span class=\"hljs-keyword\">return</span> factorial(n - <span class=\"hljs-number\">1</span>, n * total);\n}\n\t\nfactorial(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 120</span>\n</code></pre>\n<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n<h3>递归函数的改写</h3>\n<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 <code>factorial</code>需要用到一个中间变量 <code>total</code> ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>\n<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">tailFactorial</span>(<span class=\"hljs-params\">n, total</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> total;\n  <span class=\"hljs-keyword\">return</span> tailFactorial(n - <span class=\"hljs-number\">1</span>, n * total);\n}\n\t\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">factorial</span>(<span class=\"hljs-params\">n</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> tailFactorial(n, <span class=\"hljs-number\">1</span>);\n}\n\t\nfactorial(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 120</span>\n</code></pre>\n<p>上面代码通过一个正常形式的阶乘函数 <code>factorial</code> ，调用尾递归函数 <code>tailFactorial</code>，看起来就正常多了。</p>\n<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>\n<pre><code>function currying(fn, n) {\n  return function (m) {\n    return fn.call(this, m, n);\n  };\n}\n\nfunction tailFactorial(n, total) {\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n}\n\nconst factorial = currying(tailFactorial, 1);\n\nfactorial(5) // 120\n</code></pre>\n<p>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。</p>\n<p>第二种方法就简单多了，就是采用ES6的函数默认值。</p>\n<pre><code>function factorial(n, total = 1) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5) // 120\n</code></pre>\n<p>上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。</p>\n<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>\n<blockquote>\n<p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p>\n<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>\n<ol>\n<li><code>func.arguments</code>：返回调用时函数的参数。</li>\n<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>\n</ol>\n</blockquote>\n<h3>对象简写</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> o = {\n  method() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello!\"</span>;\n  }\n};\no = {<span class=\"hljs-string\">'method'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello!\"</span>;}}\n</code></pre>\n<h3>同值相等</h3>\n<p><code>Object.is(a,b)</code>判断a,b是否相等</p>\n<h3>对象拷贝</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">clone</span>(<span class=\"hljs-params\">origin</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> originProto = <span class=\"hljs-built_in\">Object</span>.getPrototypeOf(origin);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.assign(<span class=\"hljs-built_in\">Object</span>.create(originProto), origin);\n}\n</code></pre>\n<p><code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> obj = { foo: <span class=\"hljs-number\">123</span> };\n <span class=\"hljs-built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"hljs-string\">'foo'</span>)\n <span class=\"hljs-comment\">//   { value: 123,</span>\n <span class=\"hljs-comment\">//     writable: true,</span>\n <span class=\"hljs-comment\">//     enumerable: true,</span>\n <span class=\"hljs-comment\">//     configurable: true }</span>\n</code></pre>\n<p>ES6一共有6种方法可以遍历对象的属性</p>\n<blockquote>\n<p>（1）for...in</p>\n<p>for...in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p>\n<p>（2）Object.keys(obj)</p>\n<p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p>\n<p>（3）Object.getOwnPropertyNames(obj)</p>\n<p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p>\n<p>（4）Object.getOwnPropertySymbols(obj)</p>\n<p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</p>\n<p>（5）Reflect.ownKeys(obj)</p>\n<p>Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</p>\n<p>（6）Reflect.enumerate(obj)</p>\n<p>Reflect.enumerate返回一个Iterator对象，遍历对象自身的和继承的所有可枚举属性（不含Symbol属性），与for...in循环相同。</p>\n</blockquote>\n<h3>解耦定义</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> { x, y, ...z } = { x: <span class=\"hljs-number\">1</span>, y: <span class=\"hljs-number\">2</span>, a: <span class=\"hljs-number\">3</span>, b: <span class=\"hljs-number\">4</span> };\n</code></pre>\n<ol>\n<li>必须是最后一个参数</li>\n<li>等号右边必须是一个对象</li>\n<li>浅拷贝</li>\n</ol>\n<h3>Symbol（）</h3>\n<ol>\n<li>不是对象，不需要new操作符</li>\n<li>接收一个字符串参数<code>Symbol('str')</code></li>\n<li>无法比较</li>\n<li>不能运算</li>\n<li>可以转化为字符串和布尔值(同字符串)</li>\n<li>Symbol不代表一个唯一字符串，而是一个唯一值，即和自己比较时才能相等（引用地址相同）。</li>\n<li>Symbol每次调用都会创建一个新的Symbol值，但是Symbol.for()会先查找是否存在。</li>\n<li>Symbol.keyFor(target)返回登记了Symbol的键值</li>\n<li>扩展方法</li>\n<li><code>Symbol.isConcatSpreadable</code>对象的\tSymbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。</li>\n<li><code>Symbol.hasInstance</code> 对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo<a href=\"foo\">Symbol.hasInstance</a></li>\n<li><code>Symbol.species</code>对象的Symbol.species属性，指向一个方法。该对象作为构造函数创造实例时，会调用这个方法。即如果this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的实例对象。</li>\n<li><code>Symbol.match</code>对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。</li>\n<li><code>Symbol.replace</code>对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</li>\n<li><code>Symbol.search</code>对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。</li>\n<li><code>Symbol.split</code></li>\n<li><code>Symbol.iterator</code></li>\n<li><code>Symbol.toPrimitive</code></li>\n<li><code>Symbol.toStringTag</code></li>\n<li><code>Symbol.unscopables</code></li>\n</ol>\n<h3>Proxy和Reflect</h3>\n<p>Proxy用于拦截对象的操作，原本我们在对象操作时，如果需要判断条件，则需要条件判断后，再传入修改后的参数。但是Proxy提供了这种机制，可以根据行为的不同，操作对象，最简单的类型判断。而Reflect是以Proxy同方式的去执行对象上的操作，替代原来的命令式的语句，返回新对象的结果。</p>\n<p>Proxy：</p>\n<p>（1）<code>get(target, propKey, receiver)</code></p>\n<p>拦截对象属性的读取，比如proxy.foo和proxy['foo']，返回类型不限。最后一个参数receiver可选，当target对象设置了propKey属性的get函数时，receiver对象会绑定get函数的this对象。</p>\n<p>（2）<code>set(target, propKey, value, receiver)</code></p>\n<p>拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。</p>\n<p>（3）<code>has(target, propKey)</code></p>\n<p>拦截propKey in proxy的操作，返回一个布尔值。</p>\n<p>（4）<code>deleteProperty(target, propKey)</code></p>\n<p>拦截delete proxy[propKey]的操作，返回一个布尔值。</p>\n<p>（5）<code>enumerate(target)</code></p>\n<p>拦截for (var x in proxy)，返回一个遍历器。</p>\n<p>（6）<code>ownKeys(target)</code></p>\n<p>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。</p>\n<p>（7）<code>getOwnPropertyDescriptor(target, propKey)</code></p>\n<p>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p>\n<p>（8）<code>defineProperty(target, propKey, propDesc)</code></p>\n<p>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p>\n<p>（9）<code>preventExtensions(target)</code></p>\n<p>拦截Object.preventExtensions(proxy)，返回一个布尔值。</p>\n<p>（10）<code>getPrototypeOf(target)</code></p>\n<p>拦截Object.getPrototypeOf(proxy)，返回一个对象。</p>\n<p>（11）<code>isExtensible(target)</code></p>\n<p>拦截Object.isExtensible(proxy)，返回一个布尔值。</p>\n<p>（12）<code>setPrototypeOf(target, proto)</code></p>\n<p>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</p>\n<p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p>\n<p>（13）<code>apply(target, object, args)</code></p>\n<p>拦截Proxy实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。</p>\n<p>（14）<code>construct(target, args, proxy)</code></p>\n<p>拦截Proxy实例作为构造函数调用的操作，比如new proxy(...args)。</p>\n<p>Reflect：</p>\n<ol>\n<li><code>Reflect.apply(target,thisArg,args)</code></li>\n<li><code>Reflect.construct(target,args)</code></li>\n<li><code>Reflect.get(target,name,receiver)</code></li>\n<li><code>Reflect.set(target,name,value,receiver)</code></li>\n<li><code>Reflect.defineProperty(target,name,desc)</code></li>\n<li><code>Reflect.deleteProperty(target,name)</code></li>\n<li><code>Reflect.has(target,name)</code></li>\n<li><code>Reflect.ownKeys(target)</code></li>\n<li><code>Reflect.enumerate(target)</code></li>\n<li><code>Reflect.isExtensible(target)</code></li>\n<li><code>Reflect.preventExtensions(target)</code></li>\n<li><code>Reflect.getOwnPropertyDescriptor(target, name)</code></li>\n<li><code>Reflect.getPrototypeOf(target)</code></li>\n<li><code>Reflect.setPrototypeOf(target, prototype)</code></li>\n</ol>\n<h3>取消Proxy</h3>\n<p>由revocable返回一个取消的函数（返回一个对象，proxy属性是实例，revoke属性是取消函数）</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> {proxy, revoke} = <span class=\"hljs-built_in\">Proxy</span>.revocable(target, handler);\nrevoke()；\n</code></pre>\n"}